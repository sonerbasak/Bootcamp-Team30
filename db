import json
import sqlite3
import random
from typing import Dict, List, Any, Optional, Tuple

# --- 1. Uygulama Yapılandırması ve Sabitler ---

# Oyun Kategorilerinin Tanımı
# Ana kategori adları ve bu kategoriye ait JSON anahtarları/bilgi tipleri
KATEGORILER: Dict[str, List[str]] = {
    "Seyahat İnsanı": ["gezilecekyerler", "oneriler", "TravelTips", "MajorTouristAttractions"],
    "Kültür Sever": ["unluYemekler", "coğrafiişaretler", "FamousDishes", "CulturalHighlights", "seyahathatirasi"],
    "Tarih Profesörü": ["tarih", "eserler", "müzeler", "tarihiólaylar", "History", "hangiülkedevaroldu", "FamousPersonalities"],
    "Doğa Tutkunu": ["bitkiörtüsü", "havakoşulları", "hayvancılık", "NaturalResources", "Wildlife", "GeographyAndClimate"],
    "Dünya Vatandaşı": ["CountryFlag/Image", "Capital", "Population", "OfficialLanguage(s)", "Currency", "InternationalRelations", "MajorSports", "plakaKodu", "Area", "nufus"] # Alan ve nüfus (şehir için) eklendi
}

# Seviye Atlama Eşikleri (Doğru Cevap Sayısı)
SEVIYE_ESIKLERI: List[int] = [25, 50, 100, 250, 500] # Bu eşikleri oyununuzun zorluğuna göre ayarlayabilirsiniz

# Kategori Bazlı Unvanlar
# Listedeki sıralama SEVIYE_ESIKLERI ile aynı olmalıdır.
SEVIYE_UNVANLARI: Dict[str, List[str]] = {
    "Kültür Sever": [
        "Kültür Meraklısı", "Kültür Dostu", "Kültür Bilgini", "Kültür Uzmanı", "Kültür Elçisi"
    ],
    "Seyahat İnsanı": [
        "Gezi Meraklısı", "Yolcu", "Keşifçi", "Seyyah", "Seyahat İnsanı"
    ],
    "Tarih Profesörü": [
        "Meraklı Öğrenci", "Araştırmacı", "Tarihçi", "Akademisyen", "Tarih Profesörü"
    ],
    "Doğa Tutkunu": [
        "Gözlemci", "Doğa Yürüyüşçüsü", "Ekoloji Gönüllüsü", "Ekosistem Bilgini", "Doğa Tutkunu"
    ],
    "Dünya Vatandaşı": [
        "Meraklı", "Gözlemci", "Katılımcı", "Usta", "Yaşam Ustası" # Unvanları sizin "Yaşam Ustası" unvanlarınıza göre güncelledim
    ]
}

# Veritabanı Dosya Adı
DB_NAME = "kullanici_profil_verileri.db"


# --- 2. Veritabanı Yönetimi Fonksiyonları ---

def veritabani_olustur():
    """
    Kullanıcı profilleri için SQLite veritabanı dosyasını ve gerekli tabloyu oluşturur.
    Bu fonksiyon, uygulamanızın başlangıcında veya kurulumunda BİR KEZ çağrılmalıdır.
    """
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()

    # 'kullanici_profil' tablosu, her kategori için doğru cevap sayısını ve mevcut unvanı tutar.
    # Varsayılan unvanları SEVIYE_UNVANLARI'nın ilk elemanından alıyoruz.
    cursor.execute(f'''
        CREATE TABLE IF NOT EXISTS kullanici_profil (
            kullanici_id INTEGER PRIMARY KEY,
            kultur_sever_dogru INTEGER DEFAULT 0,
            seyahat_insani_dogru INTEGER DEFAULT 0,
            tarih_profesoru_dogru INTEGER DEFAULT 0,
            doga_tutkunu_dogru INTEGER DEFAULT 0,
            dunya_vatandasi_dogru INTEGER DEFAULT 0,
            kultur_sever_unvan TEXT DEFAULT '{SEVIYE_UNVANLARI["Kültür Sever"][0]}',
            seyahat_insani_unvan TEXT DEFAULT '{SEVIYE_UNVANLARI["Seyahat İnsanı"][0]}',
            tarih_profesoru_unvan TEXT DEFAULT '{SEVIYE_UNVANLARI["Tarih Profesörü"][0]}',
            doga_tutkunu_unvan TEXT DEFAULT '{SEVIYE_UNVANLARI["Doğa Tutkunu"][0]}',
            dunya_vatandasi_unvan TEXT DEFAULT '{SEVIYE_UNVANLARI["Dünya Vatandaşı"][0]}'
        )
    ''')
    conn.commit()
    conn.close()
    print("Veritabanı ve kullanıcı profili tablosu başarıyla oluşturuldu/kontrol edildi.")

def kullanici_profil_guncelle(
    kullanici_id: int,
    kategori_dogru_sayilari: Dict[str, int],
    kategori_unvanlari: Dict[str, str]
):
    """
    Kullanıcının kategori doğru sayılarını ve unvanlarını veritabanında günceller.
    Eğer kullanıcı yoksa yeni bir kayıt oluşturur.
    Bu fonksiyon, her doğru cevaptan sonra veya bir oyun seansı bittiğinde çağrılabilir.
    """
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()

    # Önce mevcut veriyi çek
    cursor.execute('SELECT 1 FROM kullanici_profil WHERE kullanici_id = ?', (kullanici_id,))
    exists = cursor.fetchone()

    if exists:
        cursor.execute('''
            UPDATE kullanici_profil SET
                kultur_sever_dogru = ?,
                seyahat_insani_dogru = ?,
                tarih_profesoru_dogru = ?,
                doga_tutkunu_dogru = ?,
                dunya_vatandasi_dogru = ?,
                kultur_sever_unvan = ?,
                seyahat_insani_unvan = ?,
                tarih_profesoru_unvan = ?,
                doga_tutkunu_unvan = ?,
                dunya_vatandasi_unvan = ?
            WHERE kullanici_id = ?
        ''', (
            kategori_dogru_sayilari.get("Kültür Sever", 0),
            kategori_dogru_sayilari.get("Seyahat İnsanı", 0),
            kategori_dogru_sayilari.get("Tarih Profesörü", 0),
            kategori_dogru_sayilari.get("Doğa Tutkunu", 0),
            kategori_dogru_sayilari.get("Dünya Vatandaşı", 0),
            kategori_unvanlari.get("Kültür Sever", SEVIYE_UNVANLARI["Kültür Sever"][0]),
            kategori_unvanlari.get("Seyahat İnsanı", SEVIYE_UNVANLARI["Seyahat İnsanı"][0]),
            kategori_unvanlari.get("Tarih Profesörü", SEVIYE_UNVANLARI["Tarih Profesörü"][0]),
            kategori_unvanlari.get("Doğa Tutkunu", SEVIYE_UNVANLARI["Doğa Tutkunu"][0]),
            kategori_unvanlari.get("Dünya Vatandaşı", SEVIYE_UNVANLARI["Dünya Vatandaşı"][0]),
            kullanici_id
        ))
    else:
        # Yeni kullanıcıysa varsayılan unvanlarla ekle
        cursor.execute('''
            INSERT INTO kullanici_profil (
                kullanici_id, kultur_sever_dogru, seyahat_insani_dogru, tarih_profesoru_dogru,
                doga_tutkunu_dogru, dunya_vatandasi_dogru, kultur_sever_unvan,
                seyahat_insani_unvan, tarih_profesoru_unvan, doga_tutkunu_unvan, dunya_vatandasi_unvan
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            kullanici_id,
            kategori_dogru_sayilari.get("Kültür Sever", 0),
            kategori_dogru_sayilari.get("Seyahat İnsanı", 0),
            kategori_dogru_sayilari.get("Tarih Profesörü", 0),
            kategori_dogru_sayilari.get("Doğa Tutkunu", 0),
            kategori_dogru_sayilari.get("Dünya Vatandaşı", 0),
            kategori_unvanlari.get("Kültür Sever", SEVIYE_UNVANLARI["Kültür Sever"][0]),
            kategori_unvanlari.get("Seyahat İnsanı", SEVIYE_UNVANLARI["Seyahat İnsanı"][0]),
            kategori_unvanlari.get("Tarih Profesörü", SEVIYE_UNVANLARI["Tarih Profesörü"][0]),
            kategori_unvanlari.get("Doğa Tutkunu", SEVIYE_UNVANLARI["Doğa Tutkunu"][0]),
            kategori_unvanlari.get("Dünya Vatandaşı", SEVIYE_UNVANLARI["Dünya Vatandaşı"][0])
        ))
    conn.commit()
    conn.close()
    # print(f"Kullanıcı ID {kullanici_id} profil bilgileri veritabanına güncellendi.")

def kullanici_profil_getir(kullanici_id: int) -> Dict[str, Any]:
    """
    Belirli bir kullanıcı ID'sine ait profil bilgilerini veritabanından çeker.
    Eğer kullanıcı yoksa, varsayılan (sıfır doğru sayısıyla) bir profil döndürür.
    Bu fonksiyon, kullanıcının profilini göstermek veya güncellemek için kullanılabilir.
    """
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM kullanici_profil WHERE kullanici_id = ?', (kullanici_id,))
    row = cursor.fetchone()
    conn.close()

    if row:
        return {
            "kullanici_id": row[0],
            "kultur_sever_dogru": row[1],
            "seyahat_insani_dogru": row[2],
            "tarih_profesoru_dogru": row[3],
            "doga_tutkunu_dogru": row[4],
            "dunya_vatandasi_dogru": row[5],
            "kultur_sever_unvan": row[6],
            "seyahat_insani_unvan": row[7],
            "tarih_profesoru_unvan": row[8],
            "doga_tutkunu_unvan": row[9],
            "dunya_vatandasi_unvan": row[10]
        }
    else:
        # Kullanıcı yoksa varsayılan boş bir profil döndür
        return {
            "kullanici_id": kullanici_id,
            "kultur_sever_dogru": 0,
            "seyahat_insani_dogru": 0,
            "tarih_profesoru_dogru": 0,
            "doga_tutkunu_dogru": 0,
            "dunya_vatandasi_dogru": 0,
            "kultur_sever_unvan": SEVIYE_UNVANLARI["Kültür Sever"][0],
            "seyahat_insani_unvan": SEVIYE_UNVANLARI["Seyahat İnsanı"][0],
            "tarih_profesoru_unvan": SEVIYE_UNVANLARI["Tarih Profesörü"][0],
            "doga_tutkunu_unvan": SEVIYE_UNVANLARI["Doğa Tutkunu"][0],
            "dunya_vatandasi_unvan": SEVIYE_UNVANLARI["Dünya Vatandaşı"][0]
        }


# --- 3. Veri Yükleme ve Soru Oluşturma Mantığı ---

def json_verilerini_yukle(dosya_yolu: str) -> List[Dict[str, Any]]:
    """
    Belirtilen JSON dosyasından verileri yükler.
    Uygulamanızın JSON dosyalarını okumak için bu fonksiyonu kullanın.
    """
    try:
        with open(dosya_yolu, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"Hata: JSON dosyası '{dosya_yolu}' bulunamadı. Lütfen yolu kontrol edin.")
        return []
    except json.JSONDecodeError:
        print(f"Hata: '{dosya_yolu}' JSON formatı bozuk.")
        return []

# JSON DOSYALARINIZIN YOLLARINI BURADA DÜZENLEYİN
# Örneğin, eğer JSON dosyalarınız projenizin ana dizininde ise:
ulke_data_global = json_verilerini_yukle("world-info.json")
sehir_data_global = json_verilerini_yukle("tr-info.json")

# Eğer JSON dosyalarınız 'data' adında bir klasörün içindeyse,
# aşağıdaki gibi yolları güncelleyin (bu satırları yorumdan çıkarın):
# ulke_data_global = json_verilerini_yukle("data/world-info.json")
# sehir_data_global = json_verilerini_yukle("data/tr-info.json")


def soru_havuzu_olustur(ulke_data: List[Dict[str, Any]], sehir_data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Ülke ve şehir verilerinden dinamik olarak bir soru havuzu oluşturur.
    Her soru, ait olduğu kategori, doğru cevap, soru tipi ve kaynak bilgilerini içerir.
    Bu havuz, uygulamanız başladığında bir kez oluşturulmalıdır.
    """
    soru_havuzu = []

    # --- Ülke Verilerinden Soru Oluşturma ---
    for ulke in ulke_data:
        ulke_adi = ulke.get("name")
        if not ulke_adi:
            continue

        # Dünya Vatandaşı Kategorisi
        if ulke.get("Capital"):
            soru_havuzu.append({
                "kategori": "Dünya Vatandaşı",
                "soru": f"{ulke_adi}'nin başkenti neresidir?",
                "dogru_cevap": ulke["Capital"],
                "tip": "tek_secenekli", "kaynak": ulke_adi, "anahtar": "Capital"
            })
        if ulke.get("OfficialLanguage(s)"):
            lang = ulke["OfficialLanguage(s)"][0] if isinstance(ulke["OfficialLanguage(s)"], list) and ulke["OfficialLanguage(s)"] else None
            if lang:
                soru_havuzu.append({
                    "kategori": "Dünya Vatandaşı",
                    "soru": f"{ulke_adi}'nin resmi dili nedir?",
                    "dogru_cevap": lang,
                    "tip": "tek_secenekli", "kaynak": ulke_adi, "anahtar": "OfficialLanguage(s)"
                })
        if ulke.get("Population"):
            soru_havuzu.append({
                "kategori": "Dünya Vatandaşı",
                "soru": f"{ulke_adi}'nin nüfusu yaklaşık {ulke['Population']} midir?",
                "dogru_cevap": "Evet",
                "tip": "dogru_yanlis", "kaynak": ulke_adi, "anahtar": "Population",
                "alternatif_cevap": "Hayır"
            })
        if ulke.get("Area"):
            soru_havuzu.append({
                "kategori": "Dünya Vatandaşı",
                "soru": f"{ulke_adi}'nin yüz ölçümü yaklaşık {ulke['Area']} midir?",
                "dogru_cevap": "Evet",
                "tip": "dogru_yanlis", "kaynak": ulke_adi, "anahtar": "Area",
                "alternatif_cevap": "Hayır"
            })
        if ulke.get("CountryFlag/Image"):
             soru_havuzu.append({
                "kategori": "Dünya Vatandaşı",
                "soru": f"Bayrağı '{ulke['CountryFlag/Image'].split('/')[-1]}' olan ülke hangisidir?", # Sadece dosya adını göster
                "dogru_cevap": ulke_adi,
                "tip": "tek_secenekli", "kaynak": ulke_adi, "anahtar": "CountryFlag/Image"
            })


        # Kültür Sever Kategorisi
        if ulke.get("FamousDishes"):
            yemek = random.choice(ulke["FamousDishes"])
            soru_havuzu.append({
                "kategori": "Kültür Sever",
                "soru": f"'{yemek}' hangi ülkenin ünlü yemeklerindendir?",
                "dogru_cevap": ulke_adi,
                "tip": "tek_secenekli", "kaynak": ulke_adi, "anahtar": "FamousDishes"
            })
        if ulke.get("CulturalHighlights"):
            # CulturalHighlights bir string ise virgülle ayırıp rastgele birini seç
            highlight = random.choice([h.strip() for h in ulke["CulturalHighlights"].split(',')]) if isinstance(ulke["CulturalHighlights"], str) else None
            if highlight:
                soru_havuzu.append({
                    "kategori": "Kültür Sever",
                    "soru": f"'{highlight}' kültürel özelliği hangi ülkeye aittir?",
                    "dogru_cevap": ulke_adi,
                    "tip": "tek_secenekli", "kaynak": ulke_adi, "anahtar": "CulturalHighlights"
                })

        # Seyahat İnsanı Kategorisi
        if ulke.get("MajorTouristAttractions"):
            yer = random.choice(ulke["MajorTouristAttractions"])
            soru_havuzu.append({
                "kategori": "Seyahat İnsanı",
                "soru": f"'{yer}' hangi ülkede yer alan önemli bir turistik cazibe merkezidir?",
                "dogru_cevap": ulke_adi,
                "tip": "tek_secenekli", "kaynak": ulke_adi, "anahtar": "MajorTouristAttractions"
            })
        if ulke.get("TravelTips"):
            tip = ulke["TravelTips"]
            soru_havuzu.append({
                "kategori": "Seyahat İnsanı",
                "soru": f"'{tip}' seyahat ipucu hangi ülkeyle ilişkilidir?",
                "dogru_cevap": ulke_adi,
                "tip": "tek_secenekli", "kaynak": ulke_adi, "anahtar": "TravelTips"
            })

        # Tarih Profesörü Kategorisi
        if ulke.get("History"):
            # Tarih alanının ilk cümlesini veya bir kısmını kullan
            history_text = ulke['History'].split('.')[0] + "..." if '.' in ulke['History'] else ulke['History']
            soru_havuzu.append({
                "kategori": "Tarih Profesörü",
                "soru": f"Hangi ülke '{history_text}' gibi bir tarihe sahiptir?",
                "dogru_cevap": ulke_adi,
                "tip": "tek_secenekli", "kaynak": ulke_adi, "anahtar": "History"
            })
        if ulke.get("FamousPersonalities"):
            person = random.choice(ulke["FamousPersonalities"])
            soru_havuzu.append({
                "kategori": "Tarih Profesörü",
                "soru": f"'{person}' hangi ülkenin ünlü kişiliklerinden biridir?",
                "dogru_cevap": ulke_adi,
                "tip": "tek_secenekli", "kaynak": ulke_adi, "anahtar": "FamousPersonalities"
            })

        # Doğa Tutkunu Kategorisi
        if ulke.get("NaturalResources"):
            kaynak = random.choice(ulke["NaturalResources"])
            soru_havuzu.append({
                "kategori": "Doğa Tutkunu",
                "soru": f"'{kaynak}' hangi ülkenin doğal kaynaklarından biridir?",
                "dogru_cevap": ulke_adi,
                "tip": "tek_secenekli", "kaynak": ulke_adi, "anahtar": "NaturalResources"
            })
        if ulke.get("Wildlife"):
            # Wildlife bir string ise virgülle ayırıp rastgele birini seç
            animal = random.choice([a.strip() for a in ulke["Wildlife"].split(',')]) if isinstance(ulke["Wildlife"], str) else None
            if animal:
                soru_havuzu.append({
                    "kategori": "Doğa Tutkunu",
                    "soru": f"'{animal}' hangi ülkenin vahşi yaşamında görülen bir hayvandır?",
                    "dogru_cevap": ulke_adi,
                    "tip": "tek_secenekli", "kaynak": ulke_adi, "anahtar": "Wildlife"
                })
        if ulke.get("GeographyAndClimate"):
            # GeographyAndClimate alanının ilk cümlesini veya bir kısmını kullan
            geo_climate_text = ulke['GeographyAndClimate'].split('.')[0] + "..." if '.' in ulke['GeographyAndClimate'] else ulke['GeographyAndClimate']
            soru_havuzu.append({
                "kategori": "Doğa Tutkunu",
                "soru": f"Hangi ülke '{geo_climate_text}' gibi bir coğrafya ve iklime sahiptir?",
                "dogru_cevap": ulke_adi,
                "tip": "tek_secenekli", "kaynak": ulke_adi, "anahtar": "GeographyAndClimate"
            })


    # --- Şehir Verilerinden Soru Oluşturma ---
    for sehir in sehir_data:
        sehir_adi = sehir.get("name")
        if not sehir_adi:
            continue

        # Dünya Vatandaşı Kategorisi
        if sehir.get("plakaKodu"):
            soru_havuzu.append({
                "kategori": "Dünya Vatandaşı",
                "soru": f"'{sehir_adi}' şehrinin plaka kodu kaçtır?",
                "dogru_cevap": str(sehir["plakaKodu"]), # String olarak saklıyoruz
                "tip": "tek_secenekli", "kaynak": sehir_adi, "anahtar": "plakaKodu"
            })
        if sehir.get("nufus"):
            soru_havuzu.append({
                "kategori": "Dünya Vatandaşı",
                "soru": f"'{sehir_adi}' şehrinin nüfusu yaklaşık {sehir['nufus']} midir?",
                "dogru_cevap": "Evet",
                "tip": "dogru_yanlis", "kaynak": sehir_adi, "anahtar": "nufus",
                "alternatif_cevap": "Hayır"
            })

        # Kültür Sever Kategorisi
        if sehir.get("unluYemekler"):
            yemek = random.choice([y.strip() for y in sehir["unluYemekler"].split(',')])
            soru_havuzu.append({
                "kategori": "Kültür Sever",
                "soru": f"'{yemek}' hangi şehrimizin ünlü yemeklerindendir?",
                "dogru_cevap": sehir_adi,
                "tip": "tek_secenekli", "kaynak": sehir_adi, "anahtar": "unluYemekler"
            })
        if sehir.get("coğrafiişaretler"):
            isaret = random.choice([i.strip() for i in sehir["coğrafiişaretler"].split(',')])
            soru_havuzu.append({
                "kategori": "Kültür Sever",
                "soru": f"'{isaret}' coğrafi işareti hangi şehrimize aittir?",
                "dogru_cevap": sehir_adi,
                "tip": "tek_secenekli", "kaynak": sehir_adi, "anahtar": "coğrafiişaretler"
            })
        if sehir.get("seyahathatirasi"):
            hatira = sehir["seyahathatirasi"]
            soru_havuzu.append({
                "kategori": "Kültür Sever",
                "soru": f"Hangi şehirden '{hatira}' alabilirsiniz?",
                "dogru_cevap": sehir_adi,
                "tip": "tek_secenekli", "kaynak": sehir_adi, "anahtar": "seyahathatirasi"
            })


        # Seyahat İnsanı Kategorisi
        if sehir.get("gezilecekyerler"):
            yer = random.choice([y.strip() for y in sehir["gezilecekyerler"].split(',')])
            soru_havuzu.append({
                "kategori": "Seyahat İnsanı",
                "soru": f"'{yer}' hangi şehrimizde gezilecek yerler arasında bulunur?",
                "dogru_cevap": sehir_adi,
                "tip": "tek_secenekli", "kaynak": sehir_adi, "anahtar": "gezilecekyerler"
            })
        if sehir.get("oneriler"):
            oneri = sehir["oneriler"]
            soru_havuzu.append({
                "kategori": "Seyahat İnsanı",
                "soru": f"'{oneri}' önerisi hangi şehrimiz için geçerlidir?",
                "dogru_cevap": sehir_adi,
                "tip": "tek_secenekli", "kaynak": sehir_adi, "anahtar": "oneriler"
            })

        # Tarih Profesörü Kategorisi
        if sehir.get("eserler"):
            eser = random.choice([e.strip() for e in sehir["eserler"].split(',')])
            soru_havuzu.append({
                "kategori": "Tarih Profesörü",
                "soru": f"'{eser}' hangi şehrimizde yer alan önemli bir tarihi eserdir?",
                "dogru_cevap": sehir_adi,
                "tip": "tek_secenekli", "kaynak": sehir_adi, "anahtar": "eserler"
            })
        if sehir.get("tarih"):
            history_text = sehir['tarih'].split('.')[0] + "..." if '.' in sehir['tarih'] else sehir['tarih']
            soru_havuzu.append({
                "kategori": "Tarih Profesörü",
                "soru": f"Hangi şehir '{history_text}' gibi kadim bir tarihe sahiptir?",
                "dogru_cevap": sehir_adi,
                "tip": "tek_secenekli", "kaynak": sehir_adi, "anahtar": "tarih"
            })
        if sehir.get("tarihiólaylar"):
            olay = random.choice([o.strip() for o in sehir["tarihiólaylar"].split(',')])
            soru_havuzu.append({
                "kategori": "Tarih Profesörü",
                "soru": f"'{olay}' hangi şehrimizin tarihinde önemli bir olaydır?",
                "dogru_cevap": sehir_adi,
                "tip": "tek_secenekli", "kaynak": sehir_adi, "anahtar": "tarihiólaylar"
            })
        if sehir.get("hangiülkedevaroldu"):
            koken = random.choice([k.strip() for k in sehir["hangiülkedevaroldu"].split(',')])
            soru_havuzu.append({
                "kategori": "Tarih Profesörü",
                "soru": f"'{koken}' uygarlığı/devleti hangi şehrimizin tarihinde var olmuştur?",
                "dogru_cevap": sehir_adi,
                "tip": "tek_secenekli", "kaynak": sehir_adi, "anahtar": "hangiülkedevaroldu"
            })
        if sehir.get("müzeler"):
            muze = random.choice([m.strip() for m in sehir["müzeler"].split(',')]) if isinstance(sehir["müzeler"], str) else None
            if muze:
                soru_havuzu.append({
                    "kategori": "Tarih Profesörü",
                    "soru": f"'{muze}' hangi şehrimizde yer alan bir müzedir?",
                    "dogru_cevap": sehir_adi,
                    "tip": "tek_secenekli", "kaynak": sehir_adi, "anahtar": "müzeler"
                })


        # Doğa Tutkunu Kategorisi
        if sehir.get("bitkiörtüsü"):
            bitki = random.choice([b.strip() for b in sehir["bitkiörtüsü"].split(',')])
            soru_havuzu.append({
                "kategori": "Doğa Tutkunu",
                "soru": f"Hangi şehrimizin bitki örtüsünde '{bitki}' bulunur?",
                "dogru_cevap": sehir_adi,
                "tip": "tek_secenekli", "kaynak": sehir_adi, "anahtar": "bitkiörtüsü"
            })
        if sehir.get("havakoşulları"):
            hava = sehir["havakoşulları"]
            soru_havuzu.append({
                "kategori": "Doğa Tutkunu",
                "soru": f"Hangi şehrimiz '{hava}' hava koşullarına sahiptir?",
                "dogru_cevap": sehir_adi,
                "tip": "tek_secenekli", "kaynak": sehir_adi, "anahtar": "havakoşulları"
            })
        if sehir.get("hayvancılık"):
            hayvan = sehir["hayvancılık"]
            soru_havuzu.append({
                "kategori": "Doğa Tutkunu",
                "soru": f"Hangi şehrimizde '{hayvan}' yaygın olarak yapılır?",
                "dogru_cevap": sehir_adi,
                "tip": "tek_secenekli", "kaynak": sehir_adi, "anahtar": "hayvancılık"
            })


    print(f"Toplam {len(soru_havuzu)} adet potansiyel soru oluşturuldu.")
    return soru_havuzu


def soru_olustur(
    soru_havuzu: List[Dict[str, Any]],
    kategori_filtre: Optional[str] = None
) -> Optional[Dict[str, Any]]:
    """
    Soru havuzundan rastgele bir soru seçer ve kullanıcıya sunulmak üzere formatlar.
    Belirli bir kategoriye göre filtreleme yapılabilir.
    Tek seçenekli sorular için 3 yanlış seçenek üretir (toplam 4 seçenek).
    """
    secilebilir_sorular = soru_havuzu
    if kategori_filtre:
        secilebilir_sorular = [s for s in soru_havuzu if s["kategori"] == kategori_filtre]

    if not secilebilir_sorular:
        print(f"Belirtilen kriterlere uygun soru bulunamadı: Kategori={kategori_filtre}. Lütfen veri kaynaklarınızı ve kategori eşleşmelerini kontrol edin.")
        return None

    soru = random.choice(secilebilir_sorular)
    dogru_cevap = str(soru["dogru_cevap"]).strip()

    if soru["tip"] == "dogru_yanlis":
        return {
            "kategori": soru["kategori"],
            "soru": soru["soru"],
            "secenekler": ["Evet", "Hayır"],
            "dogru_cevap": dogru_cevap,
            "tip": "dogru_yanlis"
        }
    else: # Tek seçenekli sorular için
        yanlis_secenekler = set()
        
        # Tüm olası ülke ve şehir isimlerini topla (yanlış seçenekler için temel havuz)
        tum_lokasyon_adlari = [u.get("name") for u in ulke_data_global if u.get("name")] + \
                             [s.get("name") for s in sehir_data_global if s.get("name")]
        tum_lokasyon_adlari = list(set(tum_lokasyon_adlari)) # Tekrarları kaldır

        # Anahtar bazında yanlış seçenek üretimi
        # Plaka kodları için sadece plaka kodları arasından seç
        if soru.get("anahtar") == "plakaKodu":
            all_plaka_kodlari = [str(s["plakaKodu"]) for s in sehir_data_global if "plakaKodu" in s]
            potansiyel_yanlislar = [p for p in all_plaka_kodlari if p != dogru_cevap]
            random.shuffle(potansiyel_yanlislar)
            for opt in potansiyel_yanlislar:
                if len(yanlis_secenekler) < 3:
                    yanlis_secenekler.add(opt)
                else:
                    break

        # Nüfus, Alan gibi sayısal değerler için yakın veya rastgele sayısal yanlışlar
        elif soru.get("anahtar") in ["Population", "Area", "nufus"]:
            try:
                # Sadece rakamları al, virgülleri kaldır (ör: "1.8 milyon" -> "1800000")
                # Metinsel ifadeyi ayrıştırmak için regex kullanılabilir, basitçe ilk rakamı bulalım.
                import re
                dogru_sayisal_str = re.search(r'\d[\d,\.]*', dogru_cevap)
                if dogru_sayisal_str:
                    dogru_sayisal_deger = float(dogru_sayisal_str.group(0).replace('.', '').replace(',', ''))
                else:
                    raise ValueError # Sayısal değer bulunamadı

                for _ in range(5): # Daha fazla deneme ile 3 yanlış seçenek üretmeye çalış
                    sapma_oran = random.uniform(0.1, 0.5) # %10 ile %50 arası sapma
                    is_negative = random.choice([True, False])
                    sapma = dogru_sayisal_deger * sapma_oran * (-1 if is_negative else 1)
                    
                    yanlis_deger = round(dogru_sayisal_deger + sapma)
                    if yanlis_deger < 0: yanlis_deger = 0 # Nüfus, alan negatif olamaz
                    
                    # Sayıyı tekrar okunur hale getir
                    formatted_yanlis = ""
                    if yanlis_deger >= 1_000_000:
                        formatted_yanlis = f"Yaklaşık {round(yanlis_deger / 1_000_000, 1)} milyon"
                    elif yanlis_deger >= 1_000:
                        formatted_yanlis = f"Yaklaşık {round(yanlis_deger / 1_000, 0)} bin"
                    else:
                         formatted_yanlis = f"Yaklaşık {int(yanlis_deger)}"
                    
                    if formatted_yanlis.lower() != dogru_cevap.lower():
                        yanlis_secenekler.add(formatted_yanlis)
                    if len(yanlis_secenekler) == 3: break
                
            except (ValueError, AttributeError):
                pass # Sayısal olmayan değerler veya regex hatası, genel üretime düşecek


        # Bayrak görselleri için dosya adından soru soruluyorsa farklı bayrak dosya adları çek
        elif soru.get("anahtar") == "CountryFlag/Image":
            all_flag_paths = [u.get("CountryFlag/Image") for u in ulke_data_global if u.get("CountryFlag/Image")]
            potansiyel_yanlislar_flag = [f.split('/')[-1] for f in all_flag_paths if f.split('/')[-1] != dogru_cevap.split('/')[-1]] # Sadece dosya adını karşılaştır
            random.shuffle(potansiyel_yanlislar_flag)
            for opt in potansiyel_yanlislar_flag:
                if len(yanlis_secenekler) < 3:
                    # Burada yanlış seçenek olarak ülke adlarını vermek daha mantıklı olabilir
                    # Eğer soru "Bayrağı X olan ülke hangisidir?" ise, seçenekler ülke adları olmalı.
                    # Bu durumda, rastgele ülke adı ekleme mantığına düşmesi daha iyi.
                    pass # Bunu genel lokasyon adlarına bırakalım
                else:
                    break


        # Geri kalan tüm sorular ve eksik yanlış seçenekler için
        while len(yanlis_secenekler) < 3:
            # Diğer ülkelerden/şehirlerden rastgele isimler çek
            if tum_lokasyon_adlari:
                rastgele_ad = random.choice(tum_lokasyon_adlari)
                if rastgele_ad.lower() != dogru_cevap.lower() and rastgele_ad not in yanlis_secenekler:
                    yanlis_secenekler.add(rastgele_ad)
                tum_lokasyon_adlari.remove(rastgele_ad) # Tekrar seçilmemesi için
            else:
                # Veri kalmadıysa döngüden çık
                break
        
        # Hala yeterli yanlış seçenek yoksa, farklı kategorilerden rastgele bir "doğru cevap" çekmeyi dene
        if len(yanlis_secenekler) < 3:
            potansiyel_diger_cevaplar = [str(s["dogru_cevap"]).strip() for s in soru_havuzu if str(s["dogru_cevap"]).strip().lower() != dogru_cevap.lower()]
            random.shuffle(potansiyel_diger_cevaplar)
            for c in potansiyel_diger_cevaplar:
                if len(yanlis_secenekler) < 3 and c not in yanlis_secenekler:
                    yanlis_secenekler.add(c)
                if len(yanlis_secenekler) == 3: break


        secenekler = list(yanlis_secenekler)
        secenekler.append(dogru_cevap)
        random.shuffle(secenekler) # Seçenekleri karıştır

        return {
            "kategori": soru["kategori"],
            "soru": soru["soru"],
            "secenekler": secenekler,
            "dogru_cevap": dogru_cevap,
            "tip": "tek_secenekli"
        }

def cevabi_kontrol_et(soru: Dict[str, Any], kullanici_cevabi: str) -> bool:
    """
    Kullanıcının verdiği cevabın doğru olup olmadığını kontrol eder.
    Büyük/küçük harf duyarlılığı ve boşluk farklılıklarını göz ardı eder.
    Doğru/yanlış sorular için özel kontrol içerir.
    """
    normalized_kullanici_cevabi = str(kullanici_cevabi).strip().lower()
    normalized_dogru_cevap = str(soru["dogru_cevap"]).strip().lower()

    if soru["tip"] == "dogru_yanlis":
        # "Evet", "Hayır" cevaplarını kontrol et
        if normalized_dogru_cevap == "evet" and (normalized_kullanici_cevabi == "evet" or normalized_kullanici_cevabi == "e"):
            return True
        elif normalized_dogru_cevap == "hayır" and (normalized_kullanici_cevabi == "hayır" or normalized_kullanici_cevabi == "h"):
            return True
        return False
    else: # Tek seçenekli veya diğer tipler
        return normalized_kullanici_cevabi == normalized_dogru_cevap


# --- 4. Kullanıcı Unvanı Hesaplama Mantığı ---

def seviye_ve_unvan_belirle(dogru_sayisi: int, kategori_adi: str) -> str:
    """
    Kategoriye özel doğru cevap sayısına göre kullanıcının seviye unvanını döndürür.
    """
    unvanlar = SEVIYE_UNVANLARI.get(kategori_adi, ["Yok"]) # Kategori yoksa "Yok" döndür

    for i, esik in enumerate(SEVIYE_ESIKLERI):
        if dogru_sayisi < esik:
            # Eğer doğru sayısı ilk eşikten (25) azsa, başlangıç unvanını döndür.
            if i == 0:
                return unvanlar[0] # "Kültür Meraklısı" gibi ilk unvan
            else:
                # Mevcut eşiğe ulaşılmadıysa, bir önceki seviyenin unvanını döndür.
                return unvanlar[i-1]
    
    # Tüm eşikleri geçmişse en yüksek unvanı döndür
    return unvanlar[-1]

def kullanici_unvanlarini_guncelle_ve_getir(kullanici_id: int) -> Dict[str, str]:
    """
    Kullanıcının veritabanındaki doğru cevap sayılarına göre tüm kategori unvanlarını hesaplar
    ve veritabanını güncelleyip, güncel unvanları bir sözlük olarak döndürür.
    Bu fonksiyonu, kullanıcının profilini gösterirken veya doğru cevaptan sonra çağırabilirsiniz.
    """
    profil = kullanici_profil_getir(kullanici_id)
    guncel_unvanlar: Dict[str, str] = {}
    guncel_dogru_sayilari: Dict[str, int] = {} # Güncel doğru sayılarını da topla (kullanici_profil_guncelle için)

    # Her kategori için unvanı hesapla
    guncel_unvanlar["Kültür Sever"] = seviye_ve_unvan_belirle(profil["kultur_sever_dogru"], "Kültür Sever")
    guncel_dogru_sayilari["Kültür Sever"] = profil["kultur_sever_dogru"]

    guncel_unvanlar["Seyahat İnsanı"] = seviye_ve_unvan_belirle(profil["seyahat_insani_dogru"], "Seyahat İnsanı")
    guncel_dogru_sayilari["Seyahat İnsanı"] = profil["seyahat_insani_dogru"]

    guncel_unvanlar["Tarih Profesörü"] = seviye_ve_unvan_belirle(profil["tarih_profesoru_dogru"], "Tarih Profesörü")
    guncel_dogru_sayilari["Tarih Profesörü"] = profil["tarih_profesoru_dogru"]

    guncel_unvanlar["Doğa Tutkunu"] = seviye_ve_unvan_belirle(profil["doga_tutkunu_dogru"], "Doğa Tutkunu")
    guncel_dogru_sayilari["Doğa Tutkunu"] = profil["doga_tutkunu_dogru"]

    guncel_unvanlar["Dünya Vatandaşı"] = seviye_ve_unvan_belirle(profil["dunya_vatandasi_dogru"], "Dünya Vatandaşı")
    guncel_dogru_sayilari["Dünya Vatandaşı"] = profil["dunya_vatandasi_dogru"]

    # Hesaplanan unvanlar ve doğru sayılarla veritabanını güncelle
    kullanici_profil_guncelle(kullanici_id, guncel_dogru_sayilari, guncel_unvanlar)

    return guncel_unvanlar


# --- 5. Örnek Kullanım / Entegrasyon Noktaları (Uygulamanızda Nasıl Kullanacaksınız?) ---

if __name__ == "__main__":
    print("--- Uygulama Modülü Test Başlangıcı ---")

    # Adım 1: Veritabanını Başlat (Uygulama ilk çalıştığında bir kez çağırılmalı)
    veritabani_olustur()

    # Adım 2: Soru Havuzunu Oluştur (Uygulama başladığında bir kez çağırılmalı)
    # NOT: ulke_data_global ve sehir_data_global'ın doğru JSON dosyalarından yüklendiğinden emin olun!
    tum_sorular_havuzu = soru_havuzu_olustur(ulke_data_global, sehir_data_global)

    if not tum_sorular_havuzu:
        print("Soru havuzu boş, test devam edemiyor. Lütfen JSON verilerinizi ve yollarını kontrol edin.")
    else:
        # Örnek Kullanıcı ID'si (Uygulamanızdaki login sisteminden gelen ID)
        test_kullanici_id = 12345

        print(f"\n--- Kullanıcı {test_kullanici_id} için Mevcut Profil ---")
        current_profile = kullanici_profil_getir(test_kullanici_id)
        print(json.dumps(current_profile, indent=2, ensure_ascii=False))

        # Adım 3: Soru Sunumu Simülasyonu
        print("\n--- Soru Sorma ve Cevaplama Simülasyonu ---")
        for i in range(3): # Örnek olarak 3 soru soralım
            print(f"\n--- Soru {i+1} ---")

            # Rastgele bir kategori seçebiliriz veya belirli bir kategoriden soru isteyebiliriz.
            secilen_kategori = random.choice(list(KATEGORILER.keys()))
            print(f"Seçilen Kategori: {secilen_kategori}")
            soru_bilgisi = soru_olustur(tum_sorular_havuzu, kategori_filtre=secilen_kategori)

            if not soru_bilgisi:
                print("Soru oluşturulamadı, devam ediliyor...")
                continue

            print(f"Kategori: {soru_bilgisi['kategori']}")
            print(f"Soru: {soru_bilgisi['soru']}")
            for j, secenek in enumerate(soru_bilgisi["secenekler"]):
                print(f"  {j+1}. {secenek}")

            # Kullanıcıdan cevap al (Uygulamanızda bu, kullanıcı arayüzünden gelecektir)
            kullanici_cevabi_input = input("Cevabınız (seçenek numarası veya tam cevap): ").strip()

            # Adım 4: Cevabı Kontrol Et ve Profili Güncelle
            is_correct = False
            if soru_bilgisi["tip"] == "dogru_yanlis":
                is_correct = cevabi_kontrol_et(soru_bilgisi, kullanici_cevabi_input)
            else: # Tek seçenekli
                try:
                    cevap_numarasi = int(kullanici_cevabi_input)
                    if 1 <= cevap_numarasi <= len(soru_bilgisi["secenekler"]):
                        kullanici_cevabi_metin = soru_bilgisi["secenekler"][cevap_numarasi - 1]
                        is_correct = cevabi_kontrol_et(soru_bilgisi, kullanici_cevabi_metin)
                    else:
                        print("Geçersiz seçenek numarası girdiniz.")
                except ValueError: # Kullanıcı metin girdi
                    is_correct = cevabi_kontrol_et(soru_bilgisi, kullanici_cevabi_input)


            if is_correct:
                print("Doğru cevap!")
                # Mevcut doğru sayısını profilimizden çekip güncelleyelim
                current_profile = kullanici_profil_getir(test_kullanici_id) # En güncel profili çek
                
                # İlgili kategori doğru sayısını artır
                # KATEGORILER sözlüğündeki anahtarlarla veritabanı sütun adlarını eşleştir.
                kategori_sutun_adi = soru_bilgisi["kategori"].replace(" ", "_").lower() + "_dogru"
                if kategori_sutun_adi in current_profile:
                    current_profile[kategori_sutun_adi] += 1
                else:
                    print(f"Uyarı: {kategori_sutun_adi} veritabanı profilinde bulunamadı. Lütfen KATEGORILER ve veritabanı şemasını kontrol edin.")
                    
                # Profildeki doğru sayılarını kullanarak unvanları yeniden hesapla ve kaydet
                updated_unvanlar = kullanici_unvanlarini_guncelle_ve_getir(test_kullanici_id)

                print("\n--- Güncel Profil Bilgisi ---")
                print(json.dumps(kullanici_profil_getir(test_kullanici_id), indent=2, ensure_ascii=False))


            else:
                print(f"Yanlış cevap. Doğru cevap: {soru_bilgisi['dogru_cevap']}")
                # Yanlış cevapta profil güncellenmez ama yine de güncel unvanları gösterebiliriz
                print("\n--- Güncel Profil Bilgisi (Cevap Yanlış Oldu) ---")
                print(json.dumps(kullanici_profil_getir(test_kullanici_id), indent=2, ensure_ascii=False))

    print("\n--- Uygulama Modülü Test Bitti ---")        
